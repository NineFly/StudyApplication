package com.ruaho.studyapp.goodcode.suanfa;

/**
 * Created by ruaho on 2018/1/31.
 */
public class SuanFaDemo {
/**
 算法
 1:类别
 1）插入排序（直接插入排序、希尔排序）

 2）交换排序（冒泡排序、快速排序）

 3）选择排序（直接选择排序、堆排序）

 4）归并排序

 5）分配排序（基数排序）

 ////////////////////////////////
 2:插入排序:算法描述：
 对于给定的一个数组，初始时假设第一个记录自成一个有序序列，其余记录为无序序列。
 接着从第二个记录开始，按照记录的大小依次将当前处理的记录插入到其之前的有序序列中，
 直至最后一个记录插入到有序序列中为止。

 具体流程如下：
 　　1、首先比较数组的前两个数据，并排序；
 　　2、比较第三个元素与前两个排好序的数据，并将第三个元素放入适当的位置；
 　　3、比较第四个元素与前三个排好序的数据，并将第四个元素放入适当的位置；
 　　 ......
 　　4、直至把最后一个元素放入适当的位置。
 具体效果如下:
 I/System.out: 1:[11, 25, 45, 26, 12, 78]
 I/System.out: 2:[11, 25, 45, 26, 12, 78]
 I/System.out: 3:[11, 25, 26, 45, 12, 78]
 I/System.out: 4:[11, 12, 25, 26, 45, 78]
 I/System.out: 5:[11, 12, 25, 26, 45, 78]

 假如有初始数据：25  11  45  26  12  78。
 　　1、首先比较25和11的大小，11小，位置互换，第一轮排序后，顺序为：[11, 25, 45, 26, 12, 78]。
 　　2、对于第三个数据45，其大于11、25，所以位置不变，顺序依旧为：[11, 25, 45, 26, 12, 78]。
 　　3、对于第四个数据26，其大于11、25，小于45，所以将其插入25和45之间，顺序为：[11, 25, 26, 45, 12, 78]。
 　　.......
 　　4、最终顺序为：[11, 12, 25, 26, 45, 78]。

 　　直接插入排序是稳定的。直接插入排序的平均时间复杂度为O(n2)。
    public void sort(int[] arr) {
        int tmp;
        for(int i = 1; i < arr.length; i++) {
            // 待插入数据
            tmp = arr[i];
            int j;
            for(j = i - 1; j >= 0; j--) {
                // 判断是否大于tmp，大于则后移一位
                if(arr[j] > tmp) {
                    arr[j+1] = arr[j];
                }else{
                    break;
                }
            }
            arr[j+1] = tmp;
            System.out.println(i + ":" + Arrays.toString(arr));
        }
    }
 ////////////////////////////////
 3:希尔排序
    图片解释:链接:http://blog.csdn.net/jianyuerensheng/article/details/51258460
     1、基本思想：
         希尔排序也成为“缩小增量排序”，其基本原理是，现将待排序的数组元素分成多个
        子序列，使得每个子序列的元素个数相对较少，然后对各个子序列分别进行直接插入
        排序，待整个待排序列“基本有序”后，最后在对所有元素进行一次直接插入排序。因
        此，我们要采用跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才
        能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。
        希尔排序是对直接插入排序算法的优化和升级。
         所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，
         例如｛2,1,3,6,4,7,5,8,9,｝就可以称为基本有序了。但像｛1,5,9,3,7,8,2,4,6｝
        这样，9在第三位，2在倒数第三位就谈不上基本有序。

     2、复杂度分析：
         希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个
        子序列，实现跳跃式移动，使得排序的效率提高。需要注意的是，增量序列的最后一个
        增量值必须等于1才行。另外，由于记录是跳跃式的移动，希尔排序并不是一种稳定的
        排序算法。 希尔排序最好时间复杂度和平均时间复杂度都是这里写图片描述，最坏时间复杂度为这里
         写图片描述。

     3、排序过程如下：
         以数组{26, 53, 67, 48, 57, 13, 48, 32, 60, 50 }为例，步长序列为{5,2,1}
         初始化关键字： [26, 53, 67, 48, 57, 13, 48, 32, 60, 50 ]
         最后的排序结果：
         13 26 32 48 48 50 53 57 60 67


    程序
     int[] data = new int[] { 26, 53, 67, 48, 57, 13, 48, 32, 60, 50 };
     shellSortSmallToBig(data);
     System.out.println(Arrays.toString(data));

     public static void shellSortSmallToBig(int[] data) {
        int j = 0;
        int temp = 0;
        for (int increment = data.length / 2; increment > 0; increment /= 2) {
            System.out.println("increment:" + increment);
            for (int i = increment; i < data.length; i++) {
                temp = data[i];
                for (j = i - increment; j >= 0; j -= increment) {
                    System.out.println("data[" + j + "]:" + data[j]);
                    if (temp < data[j]) {
                        data[j + increment] = data[j];
                    } else {
                        break;
                    }
                }
                data[j + increment] = temp;
            }
            for (int i = 0; i < data.length; i++){
                System.out.print(data[i] + " ");
            }
        }
     }
 ////////////////////////////////
4: 冒泡排序
 1、基本思想
     冒泡排序顾名思义就是整个过程像气泡一样往上升，单向冒泡排序的基本思想
     是（假设由小到大排序）：对于给定n个记录，从第一个记录开始依次对相邻
     的两个记录进行比较，当前面的记录大于后面的记录时，交换位置，进行一轮
     比较和换位后，n个记录的最大记录将位于第n位，然后对前（n-1）个记录进
     行第二轮比较；重复该过程，直到记录剩下一个为止。

 2、复杂度分析
     当最好的情况，也就是要排序的序列本身就是有序的，需要进行（n-1）次比较
     ，没有数据交换，时间复杂度为O(n).
     当最坏的情况，即待排序的表是逆序的情况，此时需要比较次数为：
     1+2+3+…+(n-1)=n(n-1)/2 次，并作等数量级的记录移动，因此总的时间复杂
     度为这里写图片描述。

 3、排序过程如下
    以数组{49,38,65,97,76,13,27,49}为例，
    图解:链接:http://blog.csdn.net/jianyuerensheng/article/details/51254271

     public static void bubbleSort(int[] a) {
        int temp;
        for (int i = 0; i < a.length - 1; ++i) {
            for (int j = a.length - 1; j > i; --j) {
                if (a[j] < a[j - 1]) {
                    temp = a[j];
                    a[j] = a[j - 1];
                    a[j - 1] = temp;
                }
            }
        }

     public static void main(String[] args) {
        int a[] = { 49,38,65,97,76,13,27,49};
        bubbleSort(a);
        System.out.println(Arrays.toString(a));
        }
     }
 ////////////////////////////////



















 */
}
